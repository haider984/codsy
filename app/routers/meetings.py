from fastapi import APIRouter, HTTPException, Depends, status, Path
from typing import List
from bson import ObjectId
from pymongo import ReturnDocument

from ..models.meeting import MeetingCreate, MeetingInDB # Import Meeting models
from ..db.mongodb import get_database
from motor.motor_asyncio import AsyncIOMotorDatabase
from ..utils.dependencies import validate_object_id_sync

router = APIRouter()

async def get_meeting_collection(db: AsyncIOMotorDatabase = Depends(get_database)):
    """Dependency to get the 'meetings' collection."""
    return db.get_collection("meetings")

@router.post("/", response_model=MeetingInDB, status_code=status.HTTP_201_CREATED, response_model_by_alias=False)
async def create_meeting(
    meeting: MeetingCreate,
    collection = Depends(get_meeting_collection)
):
    """Creates a new meeting. meet_id (_id) is auto-generated by DB, mid is generated here."""
    try:
        # Dump all fields from MeetingCreate, including the provided mid
        meeting_dict = meeting.model_dump()

        # Insert the dictionary. It now contains the 'mid' passed in the request.
        insert_result = await collection.insert_one(meeting_dict)
        # Fetch using the MongoDB-generated _id
        created_meeting = await collection.find_one({"_id": insert_result.inserted_id})
        if created_meeting:
            # Pydantic maps _id to meet_id and includes mid from DB record
            return MeetingInDB(**created_meeting)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Meeting could not be created")
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Error creating meeting: {e}")

@router.get("/", response_model=List[MeetingInDB], response_model_by_alias=False)
async def read_all_meetings(
    skip: int = 0,
    limit: int = 100,
    collection = Depends(get_meeting_collection)
):
    """Retrieves a list of meetings with pagination."""
    meetings_cursor = collection.find().skip(skip).limit(limit)
    meetings = await meetings_cursor.to_list(length=limit)
    return [MeetingInDB(**meeting) for meeting in meetings]

@router.get("/{meet_id}", response_model=MeetingInDB, response_model_by_alias=False)
async def read_meeting_by_id(
    meet_id: str = Path(..., description="The BSON ObjectId of the meeting (meet_id) as a string"),
    collection = Depends(get_meeting_collection)
):
    """Retrieves a specific meeting by ID (meet_id)."""
    validated_meet_oid = validate_object_id_sync(meet_id)
    meeting = await collection.find_one({"_id": validated_meet_oid})
    if meeting:
        return MeetingInDB(**meeting)
    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Meeting with meet_id {meet_id} not found")

@router.put("/{meet_id}", response_model=MeetingInDB, response_model_by_alias=False)
async def update_meeting(
    meeting_update: MeetingCreate,
    meet_id: str = Path(..., description="The BSON ObjectId of the meeting (meet_id) as a string"),
    collection = Depends(get_meeting_collection)
):
    """Updates an existing meeting (excluding mid)."""
    validated_meet_oid = validate_object_id_sync(meet_id)
    meeting_dict = meeting_update.model_dump(exclude_unset=True)
    if not meeting_dict:
         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="No update data provided")

    updated_meeting = await collection.find_one_and_update(
        {"_id": validated_meet_oid},
        {"$set": meeting_dict},
        return_document=ReturnDocument.AFTER
    )
    if updated_meeting:
        return MeetingInDB(**updated_meeting)
    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Meeting with meet_id {meet_id} not found for update")

@router.delete("/{meet_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_meeting(
    meet_id: str = Path(..., description="The BSON ObjectId of the meeting (meet_id) as a string"),
    collection = Depends(get_meeting_collection)
):
    """Deletes a meeting."""
    validated_meet_oid = validate_object_id_sync(meet_id)
    delete_result = await collection.delete_one({"_id": validated_meet_oid})
    if delete_result.deleted_count == 0:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Meeting with meet_id {meet_id} not found for deletion")
    return
